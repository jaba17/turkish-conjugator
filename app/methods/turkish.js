const {
	map
} = require('./utils');

const {
	_,
	length,
	reverseStr,
	getVowelsStr,
	getStrLast,
	getStrInit
} = require('./basics');

const {
	harmony,
	mutableVerbs,
	compositionExceptions
} = require('./../rules');

const {
	isNegativeVerb
} = require('./verbVerification')
/**
 * @description This function is used to extract the content before the verb root from a given verb. Ex: ETMEK -> ET
 * @param {string} str
 * @returns {string}
 */
const verbRoot = str => str.slice(0, -3);

/**
 * @description This function is used to extract the content before the negative verb root from a given verb. Ex: ETMEMEK -> ET
 * @param {string} str
 * @returns {string} 
 */
const getPositiveVerbRootFromNegativeVerb = str => str.slice(0, -5);

/**
 * @description This object contains some functions that generates Arrays with personal suffixes that will
 * be added to the conjugations
 * I = first type: im, sin, (i), iz, siniz (lar or ler is added later)
 * II = second type: im, in, (i), ik, siniz (lar or ler is added later)
 * IN = first type negative: m, zsin, z, yiz, zsiniz (lar or ler is added later. The -z is not added in first person singular and first person plurar)
 */
const arrayOfPersonalSuffixes = {
	I: (i, z = '') => [`${i}m`, `${z}s${i}n`, `${z}`, `${i}z`, `${z}s${i}n${i}z`],
	II: (i, e = i) => [`${i}m`, `${i}n`, `${i}`, `${i}k`, `${i}n${e}z`],
	IN: (i) => [`m`, `zs${i}n`, `z`, `y${i}z`, `zs${i}n${i}z`]
}

/**
 * @description This function is going to take a Verb, get its root, and count the vowels in that root
 * @param {string} - a verb where to look for vowels
 * @returns {number} - the quantity of vowels in the verb's root
 */
const vowelsQuantity = _(verbRoot, getVowelsStr, length);

/**
 * @description Does this verb have only one syllable?
 * @param {string} verb
 * @returns {boolean} - is it one syllable or not?
 */
const isSingleSyllableVerb = verb => vowelsQuantity(verb) === 1

/**
 * Returns the first vowel in a string
 * @param {string} 
 * @returns {string}
 */
const getFirstVowel = str => (str.match(/[aeiıouöü]/gi) || [ false ] )[0]

/**
 * Returns the last vowel in a string
 * @param {string} 
 * @returns {string}
 */
const getLastVowel = _(reverseStr, getFirstVowel);

const lookFor = {
	'4 way harmony': vowel => harmony.fourWays.find(stringOfVowels => {
		/**
		 * harmony.fourWays is an array with 'string of vowels' that looks like: ['aı', 'ou', 'ei', 'öü']
		 * we'll see if one of these string of vowels contains the given @param VOWEL
		 * stringOfVowels.includes(vowel) will give us one of these strings
		 * and with slice(-1) we'll get its harmony, because this strings are made for 
		 * having the harmony letter in the final of the string
		 * so the 'string of vowel': 'aı' returns -> 'ı'
		 * THIS PRINCIPLE WILL ALSO BE USED WITH THE '2 way harmony' @function in this object.
		 */
		return stringOfVowels.includes(vowel)
	}).slice(-1),
	'2 way harmony': vowel => harmony.twoWays.find(stringOfVowels => stringOfVowels.includes(vowel)).slice(-1)
}

const lookIn4Ways = lookFor['4 way harmony'];
const lookIn2Ways = lookFor['2 way harmony'];

/**
 * @description This function figure out a verb's 4-Way-Harmony 
 * @param {string} - A verb in its infinitive form (so with -mek, -mak. Ex: Etmek, Bilmek)
 * @returns {string} - a 1 length string that could be one of these: [ı, u, i, ü] representing the 4-way-harmony
 */
const get4WayHarmonyOf = _(verbRoot, getLastVowel, lookIn4Ways);

/**
 * @description This function figure out a verb's 2-Way-Harmony 
 * @param {string} - A verb in its infinitive form (so with -mek, -mak. Ex: Etmek, Bilmek)
 * @returns {string} - a 1 length string that could be one of these: [a, e] representing the 2-way-harmony
 */
const get2WayHarmonyOf = _(verbRoot, getLastVowel, lookIn2Ways);

/**
 * @description This func puts every part of the conjugation together an generates a final array.
 * @param {Object} props
 * @prop props.personalSuffixes - an array of personal suffixes generated by one of the @func in the arrayOfPersonalSuffixes Object
 * @prop props.firstPart - when a verb is composed, we need to extract the firstPart of it, @example:The firstPart of 'Yardım etmek' is: 'Yardım'
 * @prop props.verbRoot - the root of a verb (a verb without -mek or -mak, @example: Bilmek -> Bil)
 * @prop props.tenseSuffix - the verb tense suffix, example: aorist, gerund, future, past, potential... This param could be empty because sometimes props.verbRoot already has the tenseSuffix on it (in negative forms of a verb for example)
 */
	const generateResult = ({
		personalSuffixes,
		firstPart,
		verbRoot,
		tenseSuffix
	}) => {
		tenseSuffix = tenseSuffix || ''
		return map(personalSuffixes, suffix => firstPart + verbRoot + tenseSuffix + suffix);
		/**
		 * @example with verb 'bilmek'
		 * personalSuffixes will looks like: [ 'im', 'sin', '', 'iz', 'siniz', 'ler' ]
		 * 	We'll map over each element and generate conjugations
		 * verbRoot: bil 
		 * tenseSuffix: ir (when it's Aorist tense)
		 * RESULT -> [ 'bilirim','bilirsin','bilir','biliriz','bilirsiniz','bilirler' ]
		 */
	}

/**
 * Quantity of white spaces
 * @param {string} str
 * @returns {number} - quantity of white spaces in the given string 
 */
const whiteSpaces = str => (str.match(/\s/g) || []).length

var regGet = /(geçmek|etmek|yapmak|eylemek|olmak|vermek|kalmak|edilmek|demek|dilemek|gelmek|bulunmak|söylemek|durmak)$/;
var regIs = /^[a-zşüıöğç\s?]{2,}(geçmek|etmek|yapmak|eylemek|olmak|vermek|kalmak|edilmek|demek|dilemek|gelmek|bulunmak|söylemek|durmak)$/;

var regGetNeg = /(geçmemek|etmemek|yapmamak|eylememek|olmamak|vermemek|kalmamak|edilmemek|dememek|dilememek|gelmemek|bulunmamak|söylememek|durmamak)$/;
var regIsNeg = /^[a-zşüıöğç\s?]{2,}(geçmemek|etmemek|yapmamak|eylememek|olmamak|vermemek|kalmamak|edilmemek|dememek|dilememek|gelmemek|bulunmamak|söylememek|durmamak)$/;


const isAuxiliaryComposedVerb = str => regIs.test(str);

const isAuxiliaryComposedVerbInNegativeForm = str => regIsNeg.test(str);

const getAuxiliaryComposedVerb = str => (str.match(regGet) || [ false ])[0]

const getAuxiliaryComposedVerbInNegativeForm = str => (str.match(regGetNeg) || [ false ])[0];

const getInitOfComposedVerb = str => str.replace(regGet, '');

const getInitOfComposedVerbInNegativeForm = str => str.replace(regGetNeg, '');

const getProperties = verb => ({

	verb: verb,
 
	root: mutableVerbs.includes(verb) ? verbRoot(verb).replace('t', 'd') : verbRoot(verb),

	originalRoot: verbRoot(verb),

	verbSuffix: verb.slice(-3),

	vowelsLength: vowelsQuantity(verb),

	verbVowels: getVowelsStr(verbRoot(verb)),

	harmony4way: get4WayHarmonyOf(verb),

	harmony2way: get2WayHarmonyOf(verb),

	negativeSuffix: 'm' + get2WayHarmonyOf(verb),

	positiveRoot: isNegativeVerb(verb) && getPositiveVerbRootFromNegativeVerb(verb),

	isNegative: isNegativeVerb(verb),

	isSingleSyllableVerb: isSingleSyllableVerb(verb),

	// if it has white spaces it means it's composed
	isComposed: Boolean(whiteSpaces(verb)),

	initPart: Boolean(whiteSpaces(verb)) && getStrInit(verb),

	lastPart: Boolean(whiteSpaces(verb)) && getStrLast(verb),

	isAuxiliaryComposedVerb: isAuxiliaryComposedVerb(verb) && !compositionExceptions.includes(verb),

	auxiliaryVerb: getAuxiliaryComposedVerb(verb),

	initComposedVerb: isAuxiliaryComposedVerb(verb) && getInitOfComposedVerb(verb),

	isAuxiliaryComposedVerbInNegativeForm: isAuxiliaryComposedVerbInNegativeForm(verb),

	auxiliaryVerbInNegativeForm: getAuxiliaryComposedVerbInNegativeForm(verb),

	initComposedVerbInNegativeForm: isAuxiliaryComposedVerbInNegativeForm(verb) && getInitOfComposedVerbInNegativeForm(verb),

});


module.exports = {
	verbRoot,
	getPositiveVerbRootFromNegativeVerb,
	arrayOfPersonalSuffixes,
	vowelsQuantity,
	getFirstVowel,
	getLastVowel,
	lookIn4Ways,
	lookIn2Ways,
	get4WayHarmonyOf,
	get2WayHarmonyOf,
	generateResult,
	getProperties,
	whiteSpaces
}